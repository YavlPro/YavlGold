<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plan de Batalla Maestro: Operaci√≥n Luz Dorada v2.2 Gold Standard+</title>
  <meta name="description" content="Runbook definitivo v2.2 Gold Standard+: saneamiento previo, validaci√≥n post-op, rollback de emergencia y captura de evidencias, con mejoras de robustez Git y selecci√≥n de backups."/>
  <meta name="theme-color" content="#1a1510"/>
  <meta name="version" content="2.2"/>
  <style>
    :root{
      --bg:#1a1510;
      --panel:rgba(44,36,22,.92);
      --panel2:rgba(44,36,22,.75);
      --ink:#F5F5DC;
      --muted:#cdbf9f;
      --gold:#C8A752;
      --gold-2:#D4AF37;
      --bronze:#8B7355;
      --violet:#9C27B0;
      --blue:#2196F3;
      --green:#4CAF50;
      --amber:#ff9800;
      --red:#f44336;
      --border:1px solid rgba(139,115,85,.6);
      --shadow:0 10px 30px rgba(0,0,0,.5);
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0}
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,system-ui,sans-serif;
      background:var(--bg);
      color:var(--ink);
      line-height:1.65;
      padding:20px;
    }
    a{color:var(--gold-2);text-decoration:none}
    a:hover{text-decoration:underline}
    .container{
      max-width:1000px;margin:20px auto;padding:30px;
      background:var(--panel);border:var(--border);border-radius:12px;box-shadow:var(--shadow)
    }
    h1,h2,h3,h4{color:var(--gold);margin:1.25em 0 .5em}
    h1{
      text-align:center;margin-top:0;font-size:2.35rem;padding-bottom:12px;
      border-bottom:2px solid var(--bronze);text-shadow:0 2px 6px rgba(0,0,0,.5)
    }
    h2{font-size:1.85rem;border-left:4px solid var(--gold);padding-left:12px}
    h3{font-size:1.35rem;color:var(--gold-2);margin-top:1.05em}
    h4{font-size:1.15rem;color:#E5C158;margin:.8em 0}
    p,li{font-size:1.05rem;margin:.55em 0}
    strong{color:var(--gold)}
    code{
      background:#000;color:#efefef;padding:2px 6px;border-radius:6px;
      font-family:ui-monospace,Consolas,Menlo,monospace;font-size:.95rem
    }
    .lead{
      background:rgba(200,167,82,.12);border:var(--border);border-radius:10px;padding:16px;margin:12px 0 22px;color:var(--muted)
    }
    .toc{
      background:var(--panel2);border:var(--border);border-radius:10px;padding:16px 18px;margin:6px 0 22px
    }
    .toc ul{list-style:none;padding-left:0;margin:0}
    .toc li{margin:.4em 0;padding-left:8px;border-left:3px solid var(--bronze)}
    .badge{
      display:inline-block;background:var(--gold);color:#1a1510;
      padding:2px 8px;border-radius:12px;font-size:.8em;font-weight:700;margin-left:8px
    }
    .badge-critical{background:var(--red);color:#fff}
    .badge-warning{background:var(--amber);color:#1a1510}
    .badge-new{background:var(--green);color:#fff}
    .cp-guide{background:rgba(200,167,82,.08);border:var(--border);border-radius:10px;padding:14px;margin:12px 0}
    .check{
      display:flex;gap:8px;align-items:center;margin:.35em 0
    }
    .check input{width:1.1em;height:1.1em}
    .card{
      background:rgba(30,25,20,.65);
      border:1px solid var(--bronze);
      border-radius:10px;
      padding:18px 18px 22px;
      box-shadow:0 6px 20px rgba(0,0,0,.3);
      margin:18px 0;
    }
    pre{
      position:relative;
      background:#000;color:#efefef;
      border:1px solid var(--bronze);
      border-radius:10px;
      padding:16px 14px;
      overflow:auto;
      box-shadow:inset 0 3px 10px rgba(0,0,0,.55);
      margin:.8em 0 1.2em;
      line-height:1.4;
    }
    pre code{background:transparent;padding:0;border-radius:0}
    .copy-btn{
      position:absolute;right:10px;top:10px;
      background:#1e6e34;border:none;color:#fff;
      padding:6px 10px;border-radius:8px;cursor:pointer;font-size:.82rem
    }
    .copy-btn:hover{background:#238636}
    footer{
      text-align:center;margin-top:40px;padding-top:20px;border-top:1px solid var(--bronze);
      font-style:italic;color:#b79f7a
    }
    .skip-link{
      position:absolute;left:-9999px;top:auto;background:var(--gold);color:#1a1510;
      padding:6px 10px;border-radius:8px
    }
    .skip-link:focus{left:20px;top:16px;z-index:1000}
    .warning-box{
      background:rgba(255,152,0,.15);border:1px solid var(--amber);border-radius:10px;padding:14px;margin:12px 0;
    }
    .success-box{
      background:rgba(76,175,80,.15);border:1px solid var(--green);border-radius:10px;padding:14px;margin:12px 0;
    }
    @media (max-width:760px){
      .container{padding:20px;margin:12px}
      h1{font-size:1.95rem}
      h2{font-size:1.58rem}
    }
    @media print{
      body{background:#fff;color:#000}
      .container{box-shadow:none;border:1px solid #ccc}
      .card{break-inside:avoid}
      a{color:#000;text-decoration:underline}
      @page{margin:16mm}
    }
  </style>
</head>
<body>
<a href="#main" class="skip-link">Saltar al contenido</a>

<div class="container" id="main" role="main" aria-labelledby="doc-title">
  <h1 id="doc-title">Plan de Batalla Maestro: Operaci√≥n Luz Dorada v2.2 <span class="badge-new">GOLD STANDARD+</span></h1>

  <p class="lead">
    Runbook definitivo v2.2 Gold Standard+ con saneamiento previo, validaci√≥n post-operaci√≥n, rollback de emergencia documentado y captura automatizada de evidencias.
    Esta versi√≥n a√±ade <strong>mayor robustez en Git</strong> (detecci√≥n segura de repo, .gitignore sin duplicados, selecci√≥n de ramas de backup m√°s fiable) y
    clarifica el alcance del script maestro. Estabiliza el repositorio, fija el puerto can√≥nico <strong>3000</strong>, preserva el trabajo local y ejecuta la
    <em>Prueba de Fuego</em> con orquestaci√≥n reproducible (Supabase CLI 2.48.3 via npx + Vite + Mailpit).
  </p>

  <div class="toc" aria-label="√çndice">
    <ul>
      <li><a href="#fase0">0. Fase 0: Saneamiento y Verificaci√≥n (Ejecuci√≥n Obligatoria)</a></li>
      <li><a href="#parametros">1. Par√°metros Can√≥nicos del Entorno</a></li>
      <li><a href="#fase1">2. Fase 1: Preservaci√≥n de Emergencia (Backup At√≥mico)</a></li>
      <li><a href="#fase1b">3. Fase 2: Saneamiento Inicial y .gitignore</a></li>
      <li><a href="#fase2">4. Fase 3: Unificaci√≥n a Puerto 3000 (Vite + Supabase)</a></li>
      <li><a href="#fase3">5. Fase 4: Arranque Gold Standard y Prueba de Fuego</a></li>
      <li><a href="#fase-validation">6. Fase 5: Validaci√≥n Post-Operaci√≥n <span class="badge-new">NUEVO</span></a></li>
      <li><a href="#fase-rollback">7. Fase 6: Rollback de Emergencia <span class="badge-new">NUEVO</span></a></li>
      <li><a href="#fase-evidence">8. Fase 7: Captura de Evidencias <span class="badge-new">NUEVO</span></a></li>
      <li><a href="#fase4">9. Fase 8: Commits por Lotes &amp; Apertura de PR</a></li>
      <li><a href="#qa-security">10. Plan Dorado de QA ‚Äì Pruebas de Regresi√≥n de Seguridad</a></li>
      <li><a href="#appendix">11. Anexos: Artefactos Listos para Pegar</a></li>
    </ul>
  </div>

  <!-- ==== FASE 0: SANEAMIENTO ==== -->
  <section id="fase0">
    <h2>0. Fase 0: Saneamiento y Verificaci√≥n (Ejecuci√≥n Obligatoria)</h2>

    <div class="card">
      <p>
        <strong>L√≠der Asignado:</strong> <span class="badge">Kimik2 / Operador de Campo</span>
      </p>

      <p>
        Antes de cualquier manipulaci√≥n del repositorio, es imperativo ejecutar la <em>Operaci√≥n Saneamiento y Verificaci√≥n</em>.
        Esta fase audita el estado actual del terreno de batalla, mueve artefactos sensibles a cuarentena, verifica que todos los prerrequisitos
        del entorno est√©n operativos y configura el entorno DX para el escuadr√≥n.
        <strong class="badge badge-critical">BLOQUEANTE</strong>: Si esta fase falla, no se debe proceder.
      </p>

      <h3>Script de Saneamiento: pre-op-cleanup.sh</h3>
      <p>Copia el siguiente script, gu√°rdalo como <code>pre-op-cleanup.sh</code> en la ra√≠z del proyecto y ejec√∫talo:</p>

      <pre><code id="code-cleanup">#!/usr/bin/env bash
# pre-op-cleanup.sh ‚Äî Operaci√≥n Saneamiento y Verificaci√≥n v1.1
# Implementa Prioridades 1 y 2 del informe de auditor√≠a Cline
# Uso: bash pre-op-cleanup.sh

set -euo pipefail

# Detectar si estamos en un repo Git (mejora de robustez)
HAS_GIT=0
if [ -d .git ] &amp;&amp; git rev-parse --is-inside-work-tree &gt;/dev/null 2&gt;&amp;1; then
  HAS_GIT=1
else
  echo "‚ÑπÔ∏è Aviso: no se detect√≥ repo Git en el directorio actual. Se omitir√°n los pasos de commit."
fi

# ====
# 1. CREAR Y EJECUTAR pre-op-audit.sh
# ====
echo "üöÄ INICIANDO OPERACI√ìN DE SANAMIENTO Y VERIFICACI√ìN"
echo "===="
echo ""
echo "üìã FASE 1: Creando auditor pre-operacional..."

mkdir -p scripts

cat &gt; scripts/pre-op-audit.sh &lt;&lt; 'EOF'
#!/usr/bin/env bash
# scripts/pre-op-audit.sh ‚Äî PASO 0 v9.0 (Kimik2)
set -euo pipefail

echo "üîç PASO 0 ‚Äî AUDITOR√çA PREVIA A OPERACI√ìN LUZ DORADA"
echo "===="
echo "Estado de Git:"
git status --porcelain || echo "‚úó No hay repo git inicializado"
echo ""
echo "Rama actual: $(git branch --show-current 2&gt;/dev/null || echo 'N/A')"
echo "Remoto: $(git remote -v 2&gt;/dev/null | head -n1 || echo 'N/A')"
echo ""
echo "Detecci√≥n de archivos sensibles:"
[ -d .quarantine ] &amp;&amp; echo "‚ö†Ô∏è Directorio .quarantine detectado" || echo "‚úÖ Sin cuarentena previa"
[ -f apps/gold/public/env.local.js ] &amp;&amp; echo "‚ö†Ô∏è apps/gold/public/env.local.js presente" || echo "‚úÖ Limpio"
[ -f assets/apps/gold/config.local.js ] &amp;&amp; echo "‚ö†Ô∏è assets/apps/gold/config.local.js presente" || echo "‚úÖ Limpio"
[ -f assets/js/supabase-config.local.js ] &amp;&amp; echo "‚ö†Ô∏è assets/js/supabase-config.local.js presente" || echo "‚úÖ Limpio"
echo ""
echo "Verificaci√≥n de Docker:"
docker ps --format '{{.Names}}' 2&gt;/dev/null || echo "‚úó Docker no accesible"
echo ""
echo "üîç AUDITOR√çA COMPLETA"
EOF

chmod +x scripts/pre-op-audit.sh
echo "‚úÖ Auditor creado: scripts/pre-op-audit.sh"
echo ""
echo "üìä EJECUTANDO AUDITOR√çA INICIAL..."
echo "----"
bash scripts/pre-op-audit.sh
echo ""

# ====
# 2. MOVER ARCHIVOS SENSIBLES A CUARENTENA
# ====
echo "üõ°Ô∏è FASE 2: Cuarentena de archivos sensibles..."

mkdir -p .quarantine

# Buscar y mover archivos .local.js
SENSITIVE_FILES=$(find . -type f -name "*.local.js" 2&gt;/dev/null || true)

if [ -n "$SENSITIVE_FILES" ]; then
  echo "Archivos sensibles detectados:"
  echo "$SENSITIVE_FILES"
  echo ""
  while IFS= read -r file; do
    if [ -f "$file" ]; then
      # Crear subdirectorios en cuarentena si es necesario
      dirpath=$(dirname "$file")
      mkdir -p ".quarantine/$dirpath"
      # Mover con timestamp para evitar colisiones
      base=$(basename "$file")
      timestamp=$(date +%Y%m%d_%H%M%S)
      dest=".quarantine/${dirpath}/${base%.js}_${timestamp}.js"
      echo "Moviendo: $file ‚Üí $dest"
      mv "$file" "$dest"
    fi
  done &lt;&lt;&lt; "$SENSITIVE_FILES"
  echo "‚úÖ Archivos sensibles movidos a .quarantine/"
else
  echo "‚úÖ No se encontraron archivos *.local.js"
fi

echo ""

# ====
# 3. VERIFICAR Y ACTUALIZAR .gitignore
# ====
echo "üìù FASE 3: Verificando .gitignore..."

if [ ! -f .gitignore ]; then
  echo "# YavlGold .gitignore" &gt; .gitignore
fi

# A√±adir entradas si no existen (evitar duplicados)
for pattern in "*.local.js" ".quarantine/" ".env.development.local"; do
  if ! grep -q "^${pattern}$" .gitignore 2&gt;/dev/null; then
    echo "$pattern" &gt;&gt; .gitignore
    echo "‚úÖ A√±adido: $pattern"
  else
    echo "‚úÖ Ya presente: $pattern"
  fi
done

echo ""

# ====
# 4. VERIFICAR PRERREQUISITOS DEL ENTORNO
# ====
echo "üîß FASE 4: Verificaci√≥n de prerrequisitos..."
echo "----"

# Verificar Supabase CLI
echo "‚úì Verificando Supabase CLI 2.48.3..."
if ! npx supabase@2.48.3 --version &gt; /dev/null 2&gt;&amp;1; then
  echo "‚úó CR√çTICO: Supabase CLI 2.48.3 no pudo ejecutarse"
  exit 1
fi
echo "  $(npx supabase@2.48.3 --version)"

echo ""
# Verificar Docker
echo "‚úì Verificando Docker..."
if ! docker ps &gt; /dev/null 2&gt;&amp;1; then
  echo "‚úó CR√çTICO: Docker no est√° corriendo o no es accesible"
  exit 1
fi
echo "  Daemon activo - $(docker ps --format '{{.Running}}' | wc -l) contenedores"
echo ""

# Verificar Node y pnpm
echo "‚úì Verificando Node.js..."
if ! command -v node &gt; /dev/null; then
  echo "‚úó CR√çTICO: Node.js no est√° instalado"
  exit 1
fi
echo "  $(node -v)"

echo "‚úì Verificando pnpm..."
if ! command -v pnpm &gt; /dev/null; then
  echo "‚úó CR√çTICO: pnpm no est√° instalado"
  exit 1
fi
echo "  $(pnpm -v)"

echo "‚úÖ Todos los prerrequisitos SATISFECHOS"
echo ""

# ====
# 5. CREAR ARCHIVOS DE CONFIGURACI√ìN DX
# ====
echo "üíª FASE 5: Configurando entorno DX..."

mkdir -p .vscode

cat &gt; .vscode/settings.json &lt;&lt; 'EOF'
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[javascript]": {
    "editor.defaultFormatter": "vscode.typescript-language-features"
  },
  "[typescript]": {
    "editor.defaultFormatter": "vscode.typescript-language-features"
  },
  "[html]": {
    "editor.defaultFormatter": "vscode.html-language-features"
  },
  "files.eol": "\n",
  "files.insertFinalNewline": true,
  "files.trimTrailingWhitespace": true
}
EOF

echo "‚úÖ Creado: .vscode/settings.json"
echo ""

# ====
# 6. HACER COMMIT DE LA LIMPIEZA (SOLO SI HAY GIT)
# ====
echo "üì¶ FASE 6: Preparando commit de saneamiento..."

if [ "$HAS_GIT" -eq 1 ]; then
  git add .gitignore .vscode/settings.json scripts/pre-op-audit.sh || true

  if ! git diff --cached --quiet; then
    git commit -m "chore(setup): execute pre-op cleanup and sanitation
- Cuarentena de archivos sensibles (*.local.js)
- Refuerzo de .gitignore con patrones locales
- Configuraci√≥n DX (.vscode/settings.json)
- Auditor pre-operacional (scripts/pre-op-audit.sh)
- Validaci√≥n de prerrequisitos completada" || true

    echo "‚úÖ Commit creado: $(git rev-parse --short HEAD)"
    echo ""
    echo "üéâ OPERACI√ìN DE SANAMIENTO COMPLETADA CON √âXITO"
    echo "El campo de batalla est√° listo para la Operaci√≥n Luz Dorada."
  else
    echo "‚ÑπÔ∏è No hay cambios para commitear (posiblemente ya estaba saneado)"
  fi
else
  echo "‚ÑπÔ∏è No se ejecut√≥ commit de saneamiento porque no se detect√≥ repo Git."
fi

echo ""
echo "===="
echo "üöÄ PR√ìXIMO PASO: Ejecutar scripts/pre-op-audit.sh para validaci√≥n adicional si lo deseas"
echo "===="</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-cleanup')">Copiar Script</button>

      <h3>Resultado de la Fase 0</h3>
      <p>Al completar esta fase, tendr√°s:</p>
      <ul>
        <li>‚úÖ Auditor√≠a inicial ejecutada y visible</li>
        <li>‚úÖ Archivos sensibles en cuarentena (<code>.quarantine/</code>)</li>
        <li>‚úÖ <code>.gitignore</code> fortalecido y sin entradas duplicadas clave</li>
        <li>‚úÖ Prerrequisitos validados (Supabase CLI, Docker, Node, pnpm)</li>
        <li>‚úÖ Configuraci√≥n DX para VS Code aplicada</li>
        <li>‚úÖ Commit inicial de saneamiento en el historial (si hay repo Git)</li>
      </ul>
    </div>
  </section>

  <!-- ==== SECCI√ìN: PAR√ÅMETROS CAN√ìNICOS ==== -->
  <section id="parametros">
    <h2>1. Par√°metros Can√≥nicos del Entorno</h2>
    <ul>
      <li><strong>Puerto can√≥nico:</strong> 3000 (Vite sirve apps/gold en http://127.0.0.1:3000).</li>
      <li><strong>Supabase CLI:</strong> 2.48.3 via npx con <code>--workdir ./supabase</code>.</li>
      <li><strong>Mailpit:</strong> SMTP 1025; UI = mapeo de 8025 ‚Üí host:puerto (t√≠picamente 54324).</li>
      <li><strong>site_url (Supabase):</strong> http://127.0.0.1:3000</li>
      <li><strong>redirectTo:</strong> /reset-password.html</li>
      <li><strong>Whitelist Mailer:</strong> GOTRUE_MAILER_EXTERNAL_HOSTS incluye 127.0.0.1:3000</li>
    </ul>
  </section>

  <hr class="section-divider"/>

  <!-- ==== SECCI√ìN: PRESERVACI√ìN ==== -->
  <section id="fase1">
    <h2>2. Fase 1: Preservaci√≥n de Emergencia (Backup At√≥mico + Tag)</h2>

    <div class="card">
      <p>Crea rama de backup y tag con estado crudo; abre sandbox para estabilizaci√≥n:</p>

      <pre><code id="code-preserve">#!/usr/bin/env bash
# scripts/emergency-git-preservation.sh
set -euo pipefail

echo "üö® MODO PRESERVACI√ìN DE EMERGENCIA ACTIVADO"

[ -d .git ] || { echo "‚úó Ejecuta en la ra√≠z del repo (donde est√° .git)"; exit 1; }

TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
BASE="$(git rev-parse --short HEAD 2&gt;/dev/null || echo 'nohead')"
BACKUP_BRANCH="emergency_backup_${BASE}_${TIMESTAMP}"

git remote -v &gt;/dev/null || { echo "‚úó No hay remoto configurado"; exit 1; }

git checkout -b "$BACKUP_BRANCH"
git add -A
git commit -m "EMERGENCY BACKUP: Estado crudo pre-estabilizaci√≥n ${TIMESTAMP}" --no-verify || true

git tag -a "emergency/${TIMESTAMP}" -m "Snapshot ${TIMESTAMP}" || true

git push -u origin "$BACKUP_BRANCH" --no-verify || true
git push origin "emergency/${TIMESTAMP}" || true

git checkout main
git pull --rebase origin main || true
git checkout -b "architectural_stabilization_${TIMESTAMP}"

echo "‚úÖ Backup en rama: ${BACKUP_BRANCH} (tag: emergency/${TIMESTAMP})"
echo "‚úÖ Sandbox listo: architectural_stabilization_${TIMESTAMP}"</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-preserve')">Copiar</button>
    </div>
  </section>

  <!-- ==== SECCI√ìN: SANEAMIENTO ==== -->
  <section id="fase1b">
    <h2>3. Fase 2: Saneamiento Inicial y .gitignore</h2>

    <div class="card">
      <p>Mueve duplicado <code>YavlGold/</code> a cuarentena. Refuerza .gitignore y quita del tracking archivos locales:</p>

      <pre><code id="code-sanitize">#!/usr/bin/env bash
# scripts/initial-sanitize.sh (opcional pero recomendado)
set -euo pipefail

# Mover duplicado a cuarentena, si existe
mkdir -p .quarantine
if [ -d YavlGold ]; then
  mv YavlGold .quarantine/YavlGold-duplicate 2&gt;/dev/null || true
  echo "‚úÖ Directorio duplicado YavlGold/ movido a .quarantine/YavlGold-duplicate"
else
  echo "‚ÑπÔ∏è No se encontr√≥ directorio duplicado YavlGold/ en la ra√≠z"
fi

# Refuerzo .gitignore (sin duplicados)
if [ ! -f .gitignore ]; then
  echo "# YavlGold .gitignore" &gt; .gitignore
fi

for pattern in \
  "apps/gold/public/env.local.js" \
  "assets/apps/gold/config.local.js" \
  "assets/js/supabase-config.local.js" \
  ".quarantine/" \
  ".env.development.local"
do
  if ! grep -q "^${pattern}$" .gitignore 2&gt;/dev/null; then
    echo "$pattern" &gt;&gt; .gitignore
    echo "‚úÖ A√±adido a .gitignore: $pattern"
  else
    echo "‚ÑπÔ∏è Patr√≥n ya presente en .gitignore: $pattern"
  fi
done

# Quitar del tracking (si estaban versionados)
git rm --cached -f apps/gold/public/env.local.js 2&gt;/dev/null || true
git rm --cached -f assets/apps/gold/config.local.js 2&gt;/dev/null || true
git rm --cached -f assets/js/supabase-config.local.js 2&gt;/dev/null || true

git add .gitignore 2&gt;/dev/null || true
git commit -m "chore(gitignore): ignore local env/config and quarantine dir" 2&gt;/dev/null || true

echo "‚úÖ Saneamiento inicial completado"</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-sanitize')">Copiar</button>
    </div>
  </section>

  <!-- ==== SECCI√ìN: UNIFICACI√ìN ==== -->
  <section id="fase2">
    <h2>4. Fase 3: Unificaci√≥n a Puerto 3000 (Vite + Supabase)</h2>

    <div class="card">
      <h3>4.1 Vite ‚Äî server.port 3000 + HMR estable</h3>

      <pre><code id="code-vite">import { defineConfig } from 'vite'
import { resolve } from 'path'

export default defineConfig({
  root: resolve(__dirname),
  server: {
    port: 3000,
    strictPort: true,
    host: '127.0.0.1',
    hmr: {
      protocol: 'ws',
      timeout: 30000
    }
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets'
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  cacheDir: resolve(__dirname, '../../node_modules/.vite')
})</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-vite')">Copiar</button>

      <h3>4.2 Supabase ‚Äî site_url &amp; whitelist</h3>

      <pre><code id="code-siteurl"># supabase/config.toml
[auth]
site_url = "http://127.0.0.1:3000"</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-siteurl')">Copiar</button>

      <pre><code id="code-whitelist"># supabase/.env.local
GOTRUE_MAILER_EXTERNAL_HOSTS=127.0.0.1,localhost,127.0.0.1:3000,localhost:3000</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-whitelist')">Copiar</button>
    </div>
  </section>

  <!-- ==== SECCI√ìN: ARRANQUE ==== -->
  <section id="fase3">
    <h2>5. Fase 4: Arranque Gold Standard y Prueba de Fuego</h2>

    <div class="card">
      <h3>5.1 Arranque reproducible</h3>

      <pre><code id="code-start"># Supabase CLI 2.48.3 via npx (workdir)
npx -y supabase@2.48.3 stop --workdir ./supabase || true
npx -y supabase@2.48.3 start --workdir ./supabase --debug &amp;

# Vite (apps/gold) en 127.0.0.1:3000
pnpm vite --config apps/gold/vite.config.js</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-start')">Copiar</button>

      <h3>5.2 Smoke de correo /recover + Mailpit</h3>

      <pre><code id="code-smoke"># Obtener anon_key desde config.toml (simple parsing)
ANON=$(awk -F'=' '\$1 ~ /anon_key/ { v=\$2; gsub(/^[[:space:]]+|[[:space:]]+$/,"",v); gsub(/^"|"$/,"",v); print v; exit }' supabase/config.toml)

curl -sS -i -X POST "http://127.0.0.1:54321/auth/v1/recover" \
  -H "Authorization: Bearer ${ANON}" \
  -H "Content-Type: application/json" \
  --data '{"email":"test@yavlgold.local","redirect_to":"http://127.0.0.1:3000/reset-password.html"}' \
  | sed -n '1,20p'

# Detectar Mailpit UI
HP=$(docker ps --format '{{.Ports}}' | sed -nE 's/.*:([0-9]+)->8025\/tcp.*/\1/p' | head -n1)
echo "Mailpit UI: http://127.0.0.1:${HP}"

curl -sS "http://127.0.0.1:${HP}/api/v1/messages" | jq '.total'</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-smoke')">Copiar</button>

      <h3>5.3 Prueba de Fuego (checklist)</h3>
      <div class="check"><input type="checkbox" id="c1"/><label for="c1">App en http://127.0.0.1:3000 (interfaz visible)</label></div>
      <div class="check"><input type="checkbox" id="c2"/><label for="c2">Correo de reset visible en Mailpit UI</label></div>
      <div class="check"><input type="checkbox" id="c3"/><label for="c3">Click en link ‚Üí /reset-password.html ‚Üí "Contrase√±a actualizada"</label></div>
      <div class="check"><input type="checkbox" id="c4"/><label for="c4">Login con nueva contrase√±a funciona</label></div>
    </div>
  </section>

  <!-- ==== NUEVA FASE 5: VALIDACI√ìN POST-OP ==== -->
  <section id="fase-validation">
    <h2>6. Fase 5: Validaci√≥n Post-Operaci√≥n <span class="badge-new">NUEVO</span></h2>

    <div class="card">
      <p>Verificar que todos los componentes cr√≠ticos est√°n operativos despu√©s de completar las fases anteriores:</p>

      <h3>Script de Validaci√≥n: post-op-validation.sh</h3>

      <pre><code id="code-validation">#!/usr/bin/env bash
# scripts/post-op-validation.sh ‚Äî Validaci√≥n Post-Operacional v1.0
set -euo pipefail

echo "üîç INICIANDO VALIDACI√ìN POST-OPERACI√ìN"
echo "===="
echo ""

FAILURES=0

# 1. Verificar puerto 3000 activo
echo "‚úì Verificando puerto 3000..."
if curl -s http://127.0.0.1:3000 &gt; /dev/null 2&gt;&amp;1; then
  echo "  ‚úÖ Puerto 3000 responde correctamente"
else
  echo "  ‚ùå Puerto 3000 NO responde"
  ((FAILURES++))
fi
echo ""

# 2. Verificar Docker y contenedores Supabase
echo "‚úì Verificando Docker y Supabase..."
if docker ps 2&gt;/dev/null | grep -q supabase; then
  CONTAINERS=$(docker ps --format '{{.Names}}' | grep supabase | wc -l)
  echo "  ‚úÖ Docker OK - $CONTAINERS contenedores Supabase activos"
else
  echo "  ‚ùå Contenedores Supabase NO detectados"
  ((FAILURES++))
fi
echo ""

# 3. Verificar cuarentena creada
echo "‚úì Verificando directorio de cuarentena..."
if [ -d .quarantine ]; then
  FILES=$(find .quarantine -type f 2&gt;/dev/null | wc -l)
  echo "  ‚úÖ Cuarentena OK - $FILES archivos en cuarentena"
else
  echo "  ‚ö†Ô∏è Directorio .quarantine no existe (puede ser OK si no hab√≠a archivos sensibles)"
fi
echo ""

# 4. Verificar .gitignore
echo "‚úì Verificando .gitignore..."
MISSING_PATTERNS=""

for pattern in "*.local.js" ".quarantine/" ".env.development.local"; do
  if grep -q "^${pattern}$" .gitignore 2&gt;/dev/null; then
    echo "  ‚úÖ Patr√≥n presente: $pattern"
  else
    echo "  ‚ùå Patr√≥n FALTANTE: $pattern"
    MISSING_PATTERNS="${MISSING_PATTERNS} ${pattern}"
    ((FAILURES++))
  fi
done
echo ""

# 5. Verificar scripts creados
echo "‚úì Verificando scripts de operaci√≥n..."
if [ -f scripts/pre-op-audit.sh ]; then
  echo "  ‚úÖ scripts/pre-op-audit.sh presente"
else
  echo "  ‚ùå scripts/pre-op-audit.sh FALTANTE"
  ((FAILURES++))
fi
echo ""

# 6. Verificar configuraci√≥n VS Code
echo "‚úì Verificando configuraci√≥n DX..."
if [ -f .vscode/settings.json ]; then
  echo "  ‚úÖ .vscode/settings.json presente"
else
  echo "  ‚ö†Ô∏è .vscode/settings.json no encontrado"
fi
echo ""

# 7. Verificar Mailpit UI
echo "‚úì Verificando Mailpit UI..."
HP=$(docker ps --format '{{.Ports}}' 2&gt;/dev/null | sed -nE 's/.*:([0-9]+)->8025.*/\1/p' | head -n1)
if [ -n "$HP" ]; then
  if curl -s "http://127.0.0.1:${HP}/api/v1/messages" &gt; /dev/null 2&gt;&amp;1; then
    echo "  ‚úÖ Mailpit UI accesible en http://127.0.0.1:${HP}"
  else
    echo "  ‚ö†Ô∏è Puerto Mailpit detectado pero no responde"
  fi
else
  echo "  ‚ö†Ô∏è Puerto Mailpit no detectado"
fi
echo ""

# RESUMEN FINAL
echo "===="
if [ $FAILURES -eq 0 ]; then
  echo "üéâ VALIDACI√ìN POST-OPERACI√ìN: √âXITO TOTAL"
  echo "‚úÖ Todos los componentes cr√≠ticos est√°n operativos"
  echo ""
  echo "Pr√≥ximo paso: Ejecutar Prueba de Fuego o proceder con Fase 8 (Commits)"
else
  echo "‚ö†Ô∏è VALIDACI√ìN POST-OPERACI√ìN: $FAILURES FALLOS DETECTADOS"
  echo ""
  echo "Revisa los errores arriba antes de continuar."
  echo "Si es necesario, ejecuta el rollback de emergencia (Fase 6)."
  exit 1
fi
echo "===="</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-validation')">Copiar Script</button>

      <div class="success-box">
        <h4>‚úÖ Checklist de Validaci√≥n</h4>
        <div class="check"><input type="checkbox" id="v1"/><label for="v1">Puerto 3000 responde correctamente</label></div>
        <div class="check"><input type="checkbox" id="v2"/><label for="v2">Contenedores Docker Supabase activos</label></div>
        <div class="check"><input type="checkbox" id="v3"/><label for="v3">Directorio .quarantine creado</label></div>
        <div class="check"><input type="checkbox" id="v4"/><label for="v4">.gitignore contiene todos los patrones requeridos</label></div>
        <div class="check"><input type="checkbox" id="v5"/><label for="v5">Scripts operacionales presentes</label></div>
        <div class="check"><input type="checkbox" id="v6"/><label for="v6">Mailpit UI accesible</label></div>
      </div>
    </div>
  </section>

  <!-- ==== NUEVA FASE 6: ROLLBACK DE EMERGENCIA ==== -->
  <section id="fase-rollback">
    <h2>7. Fase 6: Rollback de Emergencia <span class="badge-new">NUEVO</span></h2>

    <div class="card">
      <div class="warning-box">
        <p><strong>‚ö†Ô∏è USAR SOLO EN CASO DE EMERGENCIA</strong></p>
        <p>Este procedimiento revierte todos los cambios realizados durante la Operaci√≥n Luz Dorada y restaura el estado previo desde el backup de emergencia.</p>
      </div>

      <h3>Procedimiento Manual de Rollback (3 Pasos)</h3>
      <ol>
        <li><strong>Cambiar a la rama de backup:</strong>
          <pre><code># Buscar la rama de backup m√°s reciente (por fecha de commit)
git for-each-ref --sort=-committerdate --format='%(refname:short)' 'refs/heads/emergency_backup_*'

# Cambiar manualmente a la rama elegida
git checkout emergency_backup_[hash]_[TIMESTAMP]</code></pre>
        </li>
        <li><strong>Resetear al estado limpio:</strong>
          <pre><code>git reset --hard HEAD</code></pre>
        </li>
        <li><strong>Restaurar archivos desde cuarentena:</strong>
          <pre><code>./scripts/restore-from-quarantine.sh</code></pre>
        </li>
      </ol>

      <h3>Script Automatizado: emergency-rollback.sh</h3>

      <pre><code id="code-rollback">#!/usr/bin/env bash
# scripts/emergency-rollback.sh ‚Äî Rollback Autom√°tico v1.1
set -euo pipefail

echo "üö® INICIANDO ROLLBACK DE EMERGENCIA"
echo "===="
echo ""

[ -d .git ] || { echo "‚ùå No se detect√≥ repo Git en el directorio actual"; exit 1; }

# 1. Encontrar rama de backup m√°s reciente (por fecha de commit)
echo "üîç Buscando rama de backup m√°s reciente..."

BACKUP_BRANCH=$(git for-each-ref --sort=-committerdate --format='%(refname:short)' 'refs/heads/emergency_backup_*' | head -n1)

if [ -z "$BACKUP_BRANCH" ]; then
  echo "‚ùå No se encontr√≥ rama de backup de emergencia"
  echo "Ramas disponibles (backup):"
  git branch -a | grep emergency_backup || echo " (ninguna)"
  exit 1
fi

echo "‚úÖ Rama de backup seleccionada: $BACKUP_BRANCH"
echo ""

# 2. Guardar trabajo actual (por si acaso)
echo "üíæ Guardando trabajo actual en stash..."
git stash push -m "Pre-rollback stash $(date +%Y%m%d_%H%M%S)" || true
echo ""

# 3. Cambiar a rama de backup
echo "üîÑ Cambiando a rama de backup..."
git checkout "$BACKUP_BRANCH"
echo ""

# 4. Resetear a estado limpio
echo "üßπ Reseteando a estado limpio..."
git reset --hard HEAD
echo ""

# 5. Restaurar desde cuarentena
echo "üì¶ Restaurando archivos desde cuarentena..."
if [ -f scripts/restore-from-quarantine.sh ]; then
  bash scripts/restore-from-quarantine.sh
else
  echo "‚ö†Ô∏è Script restore-from-quarantine.sh no encontrado"
  echo "   Restauraci√≥n manual requerida"
fi

echo ""
echo "===="
echo "‚úÖ ROLLBACK DE EMERGENCIA COMPLETADO"
echo ""
echo "Estado actual:"
echo "  Rama: $(git branch --show-current)"
echo "  Commit: $(git rev-parse --short HEAD)"
echo ""
echo "‚ö†Ô∏è IMPORTANTE: Revisa el estado del sistema antes de continuar"
echo "===="</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-rollback')">Copiar Script</button>

      <h3>Script de Restauraci√≥n desde Cuarentena</h3>

      <pre><code id="code-restore">#!/usr/bin/env bash
# scripts/restore-from-quarantine.sh ‚Äî Restaurar archivos desde cuarentena v1.0
set -euo pipefail

echo "üì¶ RESTAURANDO ARCHIVOS DESDE CUARENTENA"
echo "===="
echo ""

if [ ! -d .quarantine ]; then
  echo "‚ö†Ô∏è Directorio .quarantine no existe"
  echo "   No hay nada que restaurar"
  exit 0
fi

FILES_RESTORED=0

# Buscar todos los archivos .js en cuarentena
find .quarantine -type f -name "*.js" 2&gt;/dev/null | while read -r quarantined_file; do
  # Remover el prefijo .quarantine/ y el sufijo de timestamp
  original_path=$(echo "$quarantined_file" | sed 's|^.quarantine/||' | sed 's|_[0-9]\{8\}_[0-9]\{6\}\.js$|.js|')
  # Crear directorio destino si no existe
  dest_dir=$(dirname "$original_path")
  mkdir -p "$dest_dir"
  echo "Restaurando: $quarantined_file ‚Üí $original_path"
  cp "$quarantined_file" "$original_path"
  ((FILES_RESTORED++))
done

echo ""
if [ $FILES_RESTORED -gt 0 ]; then
  echo "‚úÖ $FILES_RESTORED archivos restaurados desde cuarentena"
else
  echo "‚ÑπÔ∏è No se encontraron archivos para restaurar"
fi
echo ""
echo "===="</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-restore')">Copiar Script</button>
    </div>
  </section>

  <!-- ==== NUEVA FASE 7: CAPTURA DE EVIDENCIAS ==== -->
  <section id="fase-evidence">
    <h2>8. Fase 7: Captura de Evidencias <span class="badge-new">NUEVO</span></h2>

    <div class="card">
      <p>Documentar el √©xito de la operaci√≥n mediante captura automatizada de evidencias t√©cnicas:</p>

      <h3>Script de Captura: capture-evidence.sh</h3>

      <pre><code id="code-evidence">#!/usr/bin/env bash
# scripts/capture-evidence.sh ‚Äî Captura de Evidencias v1.1
set -euo pipefail

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
EVIDENCE_DIR="evidencias/operacion_luz_dorada_${TIMESTAMP}"

echo "üì∏ INICIANDO CAPTURA DE EVIDENCIAS"
echo "===="
echo ""
echo "Directorio de evidencias: $EVIDENCE_DIR"
echo ""

# Crear directorio de evidencias
mkdir -p "$EVIDENCE_DIR"

# 1. Capturar respuesta del puerto 3000
echo "‚úì Capturando respuesta de puerto 3000..."
if curl -s http://127.0.0.1:3000 &gt; "$EVIDENCE_DIR/port-3000-response.html" 2&gt;&amp;1; then
  echo "  ‚úÖ Guardado: port-3000-response.html"
else
  echo "  ‚ö†Ô∏è Puerto 3000 no responde"
  echo "Puerto 3000 no disponible" &gt; "$EVIDENCE_DIR/port-3000-ERROR.txt"
fi

# 2. Capturar mensajes de Mailpit
echo "‚úì Capturando mensajes de Mailpit..."
HP=$(docker ps --format '{{.Ports}}' 2&gt;/dev/null | sed -nE 's/.*:([0-9]+)->8025.*/\1/p' | head -n1)
if [ -n "$HP" ]; then
  if curl -s "http://127.0.0.1:${HP}/api/v1/messages" &gt; "$EVIDENCE_DIR/mailpit-messages.json" 2&gt;&amp;1; then
    if command -v jq &gt;/dev/null 2&gt;&amp;1; then
      TOTAL=$(jq '.total // 0' "$EVIDENCE_DIR/mailpit-messages.json" 2&gt;/dev/null || echo "0")
      echo "  ‚úÖ Guardado: mailpit-messages.json (${TOTAL} mensajes)"
    else
      echo "  ‚úÖ Guardado: mailpit-messages.json (jq no disponible, conteo omitido)"
    fi
  else
    echo "  ‚ö†Ô∏è No se pudo acceder a Mailpit API"
  fi
else
  echo "  ‚ö†Ô∏è Puerto Mailpit no detectado"
  echo "Mailpit UI no disponible" &gt; "$EVIDENCE_DIR/mailpit-ERROR.txt"
fi

# 3. Capturar estado de Docker
echo "‚úì Capturando estado de Docker..."
docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' &gt; "$EVIDENCE_DIR/docker-status.txt" 2&gt;&amp;1
echo "  ‚úÖ Guardado: docker-status.txt"

# 4. Capturar log de commits recientes
echo "‚úì Capturando log de commits..."
git log --oneline --graph --decorate -15 &gt; "$EVIDENCE_DIR/git-commits.txt" 2&gt;&amp;1
echo "  ‚úÖ Guardado: git-commits.txt"

# 5. Capturar estado de Git
echo "‚úì Capturando estado de Git..."
{
  echo "=== GIT STATUS ==="
  git status
  echo ""
  echo "=== RAMA ACTUAL ==="
  git branch --show-current
  echo ""
  echo "=== REMOTO ==="
  git remote -v
} &gt; "$EVIDENCE_DIR/git-status.txt" 2&gt;&amp;1
echo "  ‚úÖ Guardado: git-status.txt"

# 6. Capturar configuraci√≥n de Supabase
echo "‚úì Capturando configuraci√≥n de Supabase..."
if [ -f supabase/config.toml ]; then
  # Copiar config.toml sin secretos sensibles
  grep -v 'jwt_secret\|anon_key\|service_role_key' supabase/config.toml &gt; "$EVIDENCE_DIR/supabase-config-safe.toml" 2&gt;&amp;1 || true
  echo "  ‚úÖ Guardado: supabase-config-safe.toml (sin secretos)"
fi

# 7. Capturar estructura del proyecto
echo "‚úì Capturando estructura del proyecto..."
tree -L 3 -I 'node_modules|.git|dist|.quarantine' &gt; "$EVIDENCE_DIR/project-structure.txt" 2&gt;/dev/null || \
  find . -maxdepth 3 \
    -not -path '*/node_modules/*' \
    -not -path '*/.git/*' \
    -not -path '*/dist/*' \
    -not -path '*/.quarantine/*' \
    &gt; "$EVIDENCE_DIR/project-structure.txt" 2&gt;&amp;1
echo "  ‚úÖ Guardado: project-structure.txt"

# 8. Capturar versiones de herramientas
echo "‚úì Capturando versiones de herramientas..."
{
  echo "=== NODE ==="
  node -v
  echo ""
  echo "=== PNPM ==="
  pnpm -v
  echo ""
  echo "=== DOCKER ==="
  docker --version
  echo ""
  echo "=== SUPABASE CLI ==="
  npx supabase@2.48.3 --version 2&gt;&amp;1 || echo "No disponible"
} &gt; "$EVIDENCE_DIR/tool-versions.txt" 2&gt;&amp;1
echo "  ‚úÖ Guardado: tool-versions.txt"

# 9. Crear README de evidencias
cat &gt; "$EVIDENCE_DIR/README.md" &lt;&lt; EOF
# Evidencias ‚Äî Operaci√≥n Luz Dorada v2.2

**Timestamp:** $TIMESTAMP  
**Operador:** \$(whoami)  
**Hostname:** \$(hostname)

## Archivos Capturados

1. **port-3000-response.html** ‚Äî Respuesta HTTP del puerto 3000 (Vite)
2. **mailpit-messages.json** ‚Äî Mensajes de correo capturados en Mailpit
3. **docker-status.txt** ‚Äî Estado de contenedores Docker
4. **git-commits.txt** ‚Äî Log de commits recientes
5. **git-status.txt** ‚Äî Estado actual de Git
6. **supabase-config-safe.toml** ‚Äî Configuraci√≥n de Supabase (sin secretos)
7. **project-structure.txt** ‚Äî Estructura del proyecto
8. **tool-versions.txt** ‚Äî Versiones de herramientas

## Validaci√≥n de Prueba de Fuego

- [ ] Puerto 3000 responde correctamente
- [ ] Mailpit muestra correo de recuperaci√≥n
- [ ] Link de reset funciona
- [ ] Login con nueva contrase√±a exitoso

## Notas

(A√±ade aqu√≠ cualquier observaci√≥n relevante)
EOF

echo "  ‚úÖ Guardado: README.md"
echo ""
echo "===="
echo "üéâ CAPTURA DE EVIDENCIAS COMPLETADA"
echo ""
echo "üìÅ Ubicaci√≥n: $EVIDENCE_DIR"
echo "üìÑ Archivos capturados: $(find "$EVIDENCE_DIR" -type f | wc -l)"
echo ""
echo "Puedes revisar las evidencias con:"
echo "  cd $EVIDENCE_DIR"
echo "  cat README.md"
echo "===="</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-evidence')">Copiar Script</button>

      <h3>Contenido de Evidencias Capturadas</h3>
      <ul>
        <li>‚úÖ <strong>port-3000-response.html</strong> ‚Äî Respuesta HTTP del puerto 3000</li>
        <li>‚úÖ <strong>mailpit-messages.json</strong> ‚Äî Mensajes de Mailpit</li>
        <li>‚úÖ <strong>docker-status.txt</strong> ‚Äî Estado de contenedores</li>
        <li>‚úÖ <strong>git-commits.txt</strong> ‚Äî Log de commits recientes</li>
        <li>‚úÖ <strong>git-status.txt</strong> ‚Äî Estado de Git</li>
        <li>‚úÖ <strong>supabase-config-safe.toml</strong> ‚Äî Config de Supabase (sin secretos)</li>
        <li>‚úÖ <strong>project-structure.txt</strong> ‚Äî Estructura del proyecto</li>
        <li>‚úÖ <strong>tool-versions.txt</strong> ‚Äî Versiones de herramientas</li>
        <li>‚úÖ <strong>README.md</strong> ‚Äî √çndice de evidencias</li>
      </ul>

      <div class="success-box">
        <h4>üí° Uso Recomendado</h4>
        <p>Ejecuta este script inmediatamente despu√©s de completar la <strong>Prueba de Fuego</strong> (Fase 4) y antes de hacer commits. Las evidencias servir√°n como:</p>
        <ul>
          <li>Documentaci√≥n t√©cnica del √©xito de la operaci√≥n</li>
          <li>Referencia para troubleshooting futuro</li>
          <li>Auditor√≠a de cambios realizados</li>
          <li>Base para reportes de progreso</li>
        </ul>
      </div>
    </div>
  </section>

  <!-- ==== SECCI√ìN: COMMITS Y PR ==== -->
  <section id="fase4">
    <h2>9. Fase 8: Commits por Lotes &amp; Apertura de PR</h2>

    <div class="card">
      <h3>9.1 Commit por lotes (legibles)</h3>
      <p><em>Nota:</em> ajusta los paths seg√∫n lo que realmente hayas tocado. Esto es una gu√≠a de estructura de commits, no un dogma.</p>

      <pre><code id="code-commits"># Documentaci√≥n
git add docs/ *.md */*.md 2&gt;/dev/null || true
git commit -m "docs: sync audit/roadmap/changelogs" || true

# Assets
git add assets/** 2&gt;/dev/null || true
git commit -m "assets: organize and prep for optimization (imgs/fonts/fa-kit)" || true

# Apps/Packages
git add apps/** packages/** 2&gt;/dev/null || true
git commit -m "feat(apps): sync modules and shared packages (v10 baseline)" || true

# Config/Tooling
git add vite.config.* vitest.config.* netlify.toml vercel.json .vscode/** 2&gt;/dev/null || true
git commit -m "chore(config): unify dev port (3000) and DX; deploy headers" || true</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-commits')">Copiar</button>

      <h3>9.2 Apertura de PR</h3>

      <pre><code id="code-pr"># Rama (ejemplo)
git push -u origin chore/auditoria-2025-11-14

# Descripci√≥n del PR
gh pr create --title "Auditor√≠a 2025-11-14: limpieza segura + unificaci√≥n puerto 3000" \
  --body-file pr-description.md

# Mostrar URL del PR
gh pr view --json url -q .url</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-pr')">Copiar</button>
    </div>
  </section>

  <!-- ==== NUEVA SECCI√ìN QA: PLAN DORADO DE REGRESI√ìN DE SEGURIDAD ==== -->
  <section id="qa-security">
    <h2>10. Plan Dorado de QA ‚Äì Pruebas de Regresi√≥n de Seguridad</h2>

    <div class="card">
      <p>
        Esta secci√≥n formaliza el <strong>Plan Dorado de QA</strong> para YavlGold: tres pruebas de regresi√≥n de
        seguridad cr√≠ticas que act√∫an como <em>guardianes</em> permanentes en el pipeline, alineadas con la
        auditor√≠a completa de 2025 y el an√°lisis de Cline.
      </p>

      <div class="warning-box">
        <p><strong>Prerequisito INFRA:</strong> estas pruebas se asumen activas una vez que el entorno local est√° estable:</p>
        <ul>
          <li>√Årbol local sincronizado y saneado (Operaci√≥n Luz Dorada v2.2 ejecutada).</li>
          <li>Backups at√≥micos (Git + f√≠sicos) ya creados y verificados.</li>
          <li>Tr√≠ada <strong>WSL‚ÄìDocker‚ÄìSupabase</strong> estable y validada por los scripts de INFRA.</li>
        </ul>
      </div>

      <h3>10.1 Objetivo de las pruebas de regresi√≥n</h3>
      <p>Las pruebas TSEC cubren los tres riesgos m√°s cr√≠ticos de seguridad:</p>
      <ul>
        <li><strong>TSEC-001 ‚Äì Integridad SRI en recursos externos:</strong> evitar ataques de cadena de suministro por CDNs sin SRI.</li>
        <li><strong>TSEC-002 ‚Äì Sanitizaci√≥n de contenido (XSS / <code>innerHTML</code>):</strong> evitar inyecci√≥n de HTML ejecutable desde inputs de usuario.</li>
        <li><strong>TSEC-003 ‚Äì Manejo seguro de sesiones (localStorage / sessionStorage):</strong> evitar exposici√≥n de tokens y banderas sensibles.</li>
      </ul>
      <p>
        Estas pruebas deben fallar cualquier PR que reintroduzca vulnerabilidades previamente mitigadas. Se
        integran en CI y forman parte del <strong>Gold Standard+</strong> de QA de YavlGold.
      </p>

      <h3>10.2 Estructura recomendada en el repositorio</h3>
      <ul>
        <li><code>tests/security/sri.spec.ts</code></li>
        <li><code>tests/security/xss-innerhtml-static.spec.ts</code></li>
        <li><code>tests/security/session-storage.spec.ts</code></li>
      </ul>

      <h4>Scripts en <code>package.json</code></h4>
      <pre><code id="code-qa-package">{
  "scripts": {
    "test": "vitest",
    "test:security": "vitest run tests/security --runInBand"
  }
}</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-qa-package')">Copiar</button>

      <!-- TSEC-001 -->
      <h3>10.3 TSEC-001 ‚Äì Integridad SRI en Recursos Externos</h3>
      <p><strong>Riesgo cubierto:</strong> scripts y estilos en CDNs sin <em>Subresource Integrity (SRI)</em>, con severidad CR√çTICA.</p>
      <p><strong>Criterios de aceptaci√≥n:</strong></p>
      <ul>
        <li>Todo <code>&lt;script src="http(s)://..."&gt;</code> externo debe incluir un atributo <code>integrity</code> no vac√≠o.</li>
        <li>Todo <code>&lt;link rel="stylesheet" href="http(s)://..."&gt;</code> externo debe incluir <code>integrity</code>.</li>
        <li>Recomendado: uso coherente de <code>crossorigin="anonymous"</code> donde aplique.</li>
      </ul>

      <h4>Prueba (Vitest + JSDOM)</h4>
      <pre><code id="code-qa-sri">// tests/security/sri.spec.ts
import { readFileSync, readdirSync, statSync } from 'fs';
import { join } from 'path';
import { JSDOM } from 'jsdom';
import { describe, it, expect } from 'vitest';

const DIST_DIR = join(__dirname, '..', '..', 'dist');

function getHtmlFiles(dir: string): string[] {
  return readdirSync(dir)
    .map((name) =&gt; join(dir, name))
    .filter((p) =&gt; statSync(p).isFile() &amp;&amp; p.endsWith('.html'));
}

describe('TSEC-001: Integridad SRI en recursos externos', () =&gt; {
  const htmlFiles = getHtmlFiles(DIST_DIR);

  it('debe encontrar al menos un HTML para analizar', () =&gt; {
    expect(htmlFiles.length).toBeGreaterThan(0);
  });

  htmlFiles.forEach((filePath) =&gt; {
    it(`todos los recursos externos deben tener atributo integrity (${filePath})`, () =&gt; {
      const html = readFileSync(filePath, 'utf8');
      const dom = new JSDOM(html);
      const document = dom.window.document;

      const scripts = Array.from(
        document.querySelectorAll&lt;HTMLScriptElement&gt;(
          'script[src^="http://"], script[src^="https://"]'
        )
      );

      const links = Array.from(
        document.querySelectorAll&lt;HTMLLinkElement&gt;(
          'link[rel="stylesheet"][href^="http://"], link[rel="stylesheet"][href^="https://"]'
        )
      );

      const nodes = [...scripts, ...links];

      const offenders = nodes.filter((el) =&gt; {
        const integrity = el.getAttribute('integrity');
        return !integrity || integrity.trim() === '';
      });

      const offenderSummaries = offenders.map((el) =&gt; {
        const tag = el.tagName.toLowerCase();
        const srcOrHref =
          el.getAttribute('src') ?? el.getAttribute('href') ?? '';
        return `&lt;${tag} ${srcOrHref}&gt;`;
      });

      expect(
        offenders.length,
        `Recursos externos sin SRI en ${filePath}:\n${offenderSummaries.join(
          '\n'
        )}`
      ).toBe(0);
    });
  });
});</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-qa-sri')">Copiar</button>

      <!-- TSEC-002 -->
      <h3>10.4 TSEC-002 ‚Äì XSS por innerHTML (An√°lisis Est√°tico)</h3>
      <p><strong>Riesgo cubierto:</strong> uso inseguro de <code>innerHTML</code> en el c√≥digo frontend. Se permite √∫nicamente cuando la l√≠nea lleva el marcador expl√≠cito <code>/* xss-allow */</code>.</p>
      <p><strong>Criterios de aceptaci√≥n:</strong></p>
      <ul>
        <li>Cualquier uso de <code>innerHTML</code> sin el marcador <code>/* xss-allow */</code> en la misma l√≠nea hace fallar la prueba.</li>
        <li>Esto obliga a revisar manualmente y justificar cada excepci√≥n.</li>
      </ul>

      <pre><code id="code-qa-xss-static">// tests/security/xss-innerhtml-static.spec.ts
import { readFileSync, readdirSync, statSync } from 'fs';
import { join } from 'path';
import { describe, it, expect } from 'vitest';

const ROOTS = [
  join(__dirname, '..', '..', 'assets', 'js'),
  join(__dirname, '..', '..', 'src')
];

const ALLOWED_MARKER = '/* xss-allow */';

function getJsFiles(dir: string): string[] {
  try {
    return readdirSync(dir)
      .map((name) =&gt; join(dir, name))
      .flatMap((p) =&gt; {
        if (statSync(p).isDirectory()) {
          return getJsFiles(p);
        }
        return p.endsWith('.js') || p.endsWith('.ts') ? [p] : [];
      });
  } catch {
    return [];
  }
}

describe('TSEC-002: Uso de innerHTML (an√°lisis est√°tico)', () =&gt; {
  const files = ROOTS.flatMap((dir) =&gt; getJsFiles(dir));

  it('debe escanear al menos un archivo JS/TS', () =&gt; {
    expect(files.length).toBeGreaterThan(0);
  });

  it('no debe haber usos de innerHTML sin marcador expl√≠cito /* xss-allow */', () =&gt; {
    const offenders: { file: string; line: number; snippet: string }[] = [];

    for (const file of files) {
      const content = readFileSync(file, 'utf8');
      const lines = content.split(/\r?\n/);

      lines.forEach((line, idx) =&gt; {
        if (line.includes('innerHTML') &amp;&amp; !line.includes(ALLOWED_MARKER)) {
          offenders.push({
            file,
            line: idx + 1,
            snippet: line.trim()
          });
        }
      });
    }

    const msg =
      offenders.length === 0
        ? ''
        : 'Usos de innerHTML sin marcador /* xss-allow */:\n' +
          offenders
            .map(
              (o) =&gt; `${o.file}:${o.line} ‚Üí ${o.snippet}`
            )
            .join('\n');

    expect(offenders.length, msg).toBe(0);
  });
});</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-qa-xss-static')">Copiar</button>

      <!-- TSEC-003 -->
      <h3>10.5 TSEC-003 ‚Äì Sesiones Seguras (localStorage / sessionStorage)</h3>
      <p><strong>Riesgo cubierto:</strong> almacenamiento inseguro de tokens o datos sensibles en <code>localStorage</code> / <code>sessionStorage</code>.</p>
      <p><strong>Estrategia:</strong> escanear el c√≥digo en busca de claves peligrosas como <code>access_token</code>, <code>refresh_token</code>, <code>jwt</code>, etc. Se permite el uso s√≥lo si la l√≠nea est√° marcada con <code>/* storage-allow */</code>.</p>

      <pre><code id="code-qa-session">// tests/security/session-storage.spec.ts
import { readFileSync, readdirSync, statSync } from 'fs';
import { join } from 'path';
import { describe, it, expect } from 'vitest';

const ROOTS = [
  join(__dirname, '..', '..', 'assets', 'js'),
  join(__dirname, '..', '..', 'src')
];

const SENSITIVE_KEYS = [
  'access_token',
  'refresh_token',
  'jwt',
  'id_token',
  'supabase_auth_token'
];

const ALLOWED_MARKER = '/* storage-allow */';

function getJsFiles(dir: string): string[] {
  try {
    return readdirSync(dir)
      .map((name) =&gt; join(dir, name))
      .flatMap((p) =&gt; {
        if (statSync(p).isDirectory()) {
          return getJsFiles(p);
        }
        return p.endsWith('.js') || p.endsWith('.ts') ? [p] : [];
      });
  } catch {
    return [];
  }
}

describe('TSEC-003: Sesiones seguras en localStorage/sessionStorage', () =&gt; {
  const files = ROOTS.flatMap((dir) =&gt; getJsFiles(dir));

  it('debe escanear al menos un archivo JS/TS', () =&gt; {
    expect(files.length).toBeGreaterThan(0);
  });

  it('no debe almacenar tokens sensibles sin marcador /* storage-allow */', () =&gt; {
    const offenders: { file: string; line: number; snippet: string }[] = [];

    for (const file of files) {
      const content = readFileSync(file, 'utf8');
      const lines = content.split(/\r?\n/);

      lines.forEach((line, idx) =&gt; {
        const hasStorageCall =
          line.includes('localStorage.setItem') ||
          line.includes('sessionStorage.setItem');

        if (!hasStorageCall) return;

        const hasSensitiveKey = SENSITIVE_KEYS.some((key) =&gt;
          line.includes(key)
        );

        if (hasSensitiveKey &amp;&amp; !line.includes(ALLOWED_MARKER)) {
          offenders.push({
            file,
            line: idx + 1,
            snippet: line.trim()
          });
        }
      });
    }

    const msg =
      offenders.length === 0
        ? ''
        : 'Almacenamiento inseguro de tokens en storage:\n' +
          offenders
            .map(
              (o) =&gt; `${o.file}:${o.line} ‚Üí ${o.snippet}`
            )
            .join('\n');

    expect(offenders.length, msg).toBe(0);
  });
});</code></pre>
      <button class="copy-btn" onclick="copyBlock(event,'code-qa-session')">Copiar</button>
    </div>
  </section>

  <!-- ==== SECCI√ìN: ANEXOS ==== -->
  <section id="appendix">
    <h2>11. Anexos ‚Äî Artefactos Listos para Pegar</h2>

    <h3>11.1 .gitignore (refuerzo)</h3>
    <pre><code id="code-ign">apps/gold/public/env.local.js
assets/apps/gold/config.local.js
assets/js/supabase-config.local.js
.quarantine/
.env.development.local
evidencias/</code></pre>
    <button class="copy-btn" onclick="copyBlock(event,'code-ign')">Copiar</button>

    <h3>11.2 .editorconfig (opcional)</h3>
    <pre><code id="code-dx"># .editorconfig
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true</code></pre>
    <button class="copy-btn" onclick="copyBlock(event,'code-dx')">Copiar</button>

    <h3>11.3 Script Maestro: run-full-operation.sh</h3>
    <p><em>Importante:</em> este script orquesta las fases cr√≠ticas autom√°ticas (0, 1, 5 y 7). Las fases 2, 3, 4, 6 y 8 requieren criterio humano y se ejecutan manualmente.</p>

    <pre><code id="code-full">#!/usr/bin/env bash
# scripts/run-full-operation.sh ‚Äî Ejecuta las fases autom√°ticas de Operaci√≥n Luz Dorada v2.2
set -euo pipefail

echo "üöÄ OPERACI√ìN LUZ DORADA v2.2 ‚Äî EJECUCI√ìN AUTOMATIZADA (FASES 0, 1, 5, 7)"
echo "===="
echo ""

# Fase 0: Saneamiento
echo "üìã FASE 0: Saneamiento y Verificaci√≥n"
bash pre-op-cleanup.sh || { echo "‚ùå Fase 0 fall√≥"; exit 1; }
echo ""

# Fase 1: Preservaci√≥n
echo "üìã FASE 1: Preservaci√≥n de Emergencia"
bash scripts/emergency-git-preservation.sh || { echo "‚ùå Fase 1 fall√≥"; exit 1; }
echo ""

echo "‚ÑπÔ∏è Recuerda ejecutar manualmente:"
echo "   - Fase 2: scripts/initial-sanitize.sh (saneamiento inicial y duplicado YavlGold/)"
echo "   - Fase 3: ajustes de Vite/Supabase a puerto 3000"
echo "   - Fase 4: Arranque Gold Standard + Prueba de Fuego"
echo ""

# Fase 5: Validaci√≥n
echo "üìã FASE 5: Validaci√≥n Post-Operaci√≥n"
bash scripts/post-op-validation.sh || { echo "‚ùå Validaci√≥n fall√≥"; exit 1; }
echo ""

# Fase 7: Evidencias
echo "üìã FASE 7: Captura de Evidencias"
bash scripts/capture-evidence.sh || { echo "‚ö†Ô∏è Captura de evidencias fall√≥ (no cr√≠tico)"; }
echo ""

echo "===="
echo "üéâ OPERACI√ìN LUZ DORADA v2.2 COMPLETADA (FASES AUTOM√ÅTICAS)"
echo "Revisa el README de evidencias y abre tu PR (Fase 8)."
echo "===="</code></pre>
    <button class="copy-btn" onclick="copyBlock(event,'code-full')">Copiar</button>
  </section>

  <!-- ==== FOOTER ==== -->
  <footer>
    <p><strong>Plan de Batalla Maestro: Operaci√≥n Luz Dorada v2.2 Gold Standard+</strong></p>
    <p>Runbook Definitivo con Validaci√≥n, Rollback, Captura de Evidencias y QA de Seguridad</p>
    <p style="margin-top:10px;color:var(--gold)">‚ú® Gold Standard Achieved ‚ú®</p>
  </footer>
</div>

<!-- ==== SCRIPT DE FUNCIONALIDAD ==== -->
<div id="live" role="status" aria-live="polite" style="position:fixed;left:-9999px;top:auto;"></div>
<script>
  function copyBlock(ev, id) {
    const el = document.getElementById(id);
    const text = el ? el.textContent : '';
    const btn = ev && ev.target ? ev.target : null;
    const live = document.getElementById('live');

    const setOK = (msg) => {
      if (btn) {
        const orig = btn.textContent;
        btn.textContent = '‚úì Copiado';
        btn.style.background = '#2ea043';
        setTimeout(() => {
          btn.textContent = orig;
          btn.style.background = '#1e6e34';
        }, 1600);
      }
      if (live) live.textContent = msg || 'Copiado al portapapeles';
    };

    const setERR = (msg) => {
      if (live) live.textContent = msg || 'No se pudo copiar';
      alert(msg || 'No se pudo copiar. Copia manualmente.');
    };

    if (!text) {
      setERR('Bloque vac√≠o/no encontrado');
      return;
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text)
        .then(() => setOK())
        .catch(() => fallbackCopy(text, setOK, setERR));
    } else {
      fallbackCopy(text, setOK, setERR);
    }
  }

  function fallbackCopy(text, ok, err) {
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly', '');
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const done = document.execCommand('copy');
      document.body.removeChild(ta);
      done ? ok('Contenido copiado (fallback)') : err('No se pudo copiar (fallback)');
    } catch(e) {
      err('No se pudo copiar (excepci√≥n)');
    }
  }
</script>
</body>
</html>