<!DOCTYPE html>
<html lang="es">

<head>
    <script type="module" src="../dashboard/auth-guard.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YavlGold Crypto - Market Data</title>
    <meta name="description" content="YavlGold Crypto market data V1.">
    <meta property="og:title" content="YavlGold Crypto - Market Data">
    <link rel="icon" type="image/webp" href="/brand/logo.webp">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Rajdhani:wght@400;600&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="/assets/css/tokens.css">
    <link rel="stylesheet" href="/assets/css/motion-pack.css">
    <link rel="stylesheet" href="./crypto.css">
</head>

<body class="crypto-page">
    <header class="crypto-header">
        <nav class="crypto-nav" aria-label="Navegacion principal">
            <a class="nav-back" href="/dashboard/" aria-label="Volver al dashboard">
                <i class="fas fa-arrow-left" aria-hidden="true"></i>
                <span>Atras</span>
            </a>
            <div class="nav-title">MERCADO</div>
            <button id="notification-bell" class="nav-icon btn-notification notification-bell yg-glowpulse"
                type="button" aria-label="Notificaciones" title="Notificaciones">
                <i class="fas fa-bell" aria-hidden="true"></i>
                <span id="notification-badge" class="notification-badge" style="display: none;">0</span>
            </button>
        </nav>
    </header>

    <main class="crypto-main">
        <div class="crypto-container">
            <section class="crypto-hero">
                <div class="crypto-brand">
                    <img src="/brand/logo.webp" alt="YavlGold" class="logo">
                    <div class="crypto-heading">
                        <h1 class="title">YAVLGOLD CRYPTO</h1>
                        <p class="subtitle">Market Data V1</p>
                    </div>
                </div>

                <div class="status-badge">
                    <span class="status-dot yg-pulse" aria-hidden="true"></span>
                    <span class="status-text" id="market-status-text">CONECTANDO</span>
                </div>

                <p class="description">
                    Datos publicos de Binance para spot market. Actualizacion automatica cada 20s.
                </p>
            </section>

            <section class="crypto-panels">
                <div class="fng-card" id="fng-card" data-state="neutral">
                    <div class="fng-header">
                        <h2 class="fng-title">Fear & Greed Index</h2>
                        <span class="fng-updated" id="fng-updated">--</span>
                    </div>
                    <div class="fng-bar">
                        <span class="fng-marker" id="fng-marker" aria-hidden="true"></span>
                    </div>
                    <div class="fng-scale">
                        <span>0</span>
                        <span>25</span>
                        <span>50</span>
                        <span>75</span>
                        <span>100</span>
                    </div>
                    <div class="fng-value">
                        <span class="fng-number" id="fng-value">--</span>
                        <span class="fng-label" id="fng-label">Cargando</span>
                    </div>
                    <div class="fng-error" id="fng-error" aria-live="polite"></div>
                </div>

                <div class="market">
                    <div class="market-header">
                        <h2 class="market-title">Spot Market</h2>
                        <span class="market-updated" id="market-updated">--</span>
                    </div>
                    <div class="market-grid" id="market-grid"></div>
                    <div class="market-error" id="market-error" aria-live="polite"></div>
                </div>
            </section>
        </div>
    </main>

    <footer class="crypto-footer" id="app-footer">
        <p>(c) <span id="footer-year">2026</span> YavlGold - Open Source (MIT License)</p>
        <p class="footer-meta">Version <span id="footer-version">9.4.0</span> - Pulso Vital -
            <a class="footer-link" href="/">Inicio</a>
        </p>
    </footer>

    <div class="crypto-modal" id="crypto-detail-modal" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="crypto-modal-backdrop" data-modal-close></div>
        <div class="crypto-modal-content" role="document">
            <div class="crypto-modal-header">
                <div class="crypto-modal-title" id="crypto-modal-title">BTC/USDT</div>
                <button class="crypto-modal-close" type="button" data-modal-close aria-label="Cerrar">
                    <i class="fas fa-xmark" aria-hidden="true"></i>
                </button>
            </div>
            <div class="crypto-chart" id="crypto-chart-container">
                <canvas id="crypto-chart-canvas"></canvas>
            </div>
        </div>
    </div>

    <script type="module" src="../assets/js/utils/activityTracker.js"></script>
    <script type="module" src="./crypto.js"></script>
    <script type="module">
        import { NotificationsManager } from '../assets/js/components/notifications.js';

        window.YGActivity?.attachModuleTracking('crypto', { title: 'Crypto', path: '/crypto/' });

        const CRYPTO_ALERTS = [
            {
                id: 'crypto-alert-btc',
                title: 'Bitcoin ha superado los $95k',
                message: 'Ruptura confirmada en BTC/USDT.',
                type: 'crypto-bull',
                is_read: false,
                created_at: new Date(Date.now() - 12 * 60000).toISOString()
            },
            {
                id: 'crypto-alert-fng',
                title: 'Fear & Greed Index entro en zona NEUTRAL',
                message: 'Sentimiento estable en el mercado.',
                type: 'crypto-neutral',
                is_read: false,
                created_at: new Date(Date.now() - 45 * 60000).toISOString()
            },
            {
                id: 'crypto-alert-gas',
                title: 'Ethereum gas fees estan bajos',
                message: 'Actividad baja en la red.',
                type: 'crypto-gas',
                is_read: false,
                created_at: new Date(Date.now() - 2 * 3600000).toISOString()
            }
        ];

        const cloneCryptoAlerts = () => CRYPTO_ALERTS.map((alert) => ({ ...alert }));

        function initCryptoNotifications() {
            if (!NotificationsManager) return;

            const ensureData = () => {
                if (!NotificationsManager._notifications || NotificationsManager._notifications.length === 0) {
                    NotificationsManager._notifications = cloneCryptoAlerts();
                }
            };

            NotificationsManager._getIcon = function (type) {
                switch (type) {
                    case 'crypto-bull':
                        return '<i class="fas fa-arrow-trend-up"></i>';
                    case 'crypto-neutral':
                        return '<i class="fas fa-circle-info"></i>';
                    case 'crypto-gas':
                        return '<i class="fas fa-fire"></i>';
                    default:
                        return '<i class="fas fa-bell"></i>';
                }
            };

            NotificationsManager.checkUnread = async function () {
                ensureData();
                this._unreadCount = this._notifications.filter((n) => !n.is_read).length;
                this._updateBadge();
            };

            NotificationsManager.showNotifications = async function () {
                ensureData();
                this._renderDropdown();
            };

            NotificationsManager._markAsRead = async function (notificationId) {
                ensureData();
                const notification = this._notifications.find((n) => n.id === notificationId);
                if (notification) {
                    notification.is_read = true;
                }
                this._unreadCount = this._notifications.filter((n) => !n.is_read).length;
                this._updateBadge();
                this._renderDropdown();
            };

            NotificationsManager.markAllRead = async function () {
                ensureData();
                this._notifications = this._notifications.map((n) => ({ ...n, is_read: true }));
                this._unreadCount = 0;
                this._updateBadge();
                const dropdown = document.getElementById('notifications-dropdown');
                if (dropdown) dropdown.remove();
                this._showToast('Alertas marcadas como leidas', 'success');
            };
        }

        initCryptoNotifications();
        NotificationsManager.init();

        const SPARKLINE_POINTS = 12;
        const SPARKLINE_WIDTH = 100;
        const SPARKLINE_HEIGHT = 40;
        const SPARKLINE_COLORS = {
            up: '#00ff88',
            down: '#ff0055'
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        function hashString(value) {
            let hash = 0;
            for (let i = 0; i < value.length; i += 1) {
                hash = ((hash << 5) - hash) + value.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }

        function mulberry32(seed) {
            return function () {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }

        function getChangeDirection(changeEl) {
            if (!changeEl) return 'up';
            if (changeEl.classList.contains('down')) return 'down';
            if (changeEl.classList.contains('up')) return 'up';
            const text = (changeEl.textContent || '').trim();
            return text.startsWith('-') ? 'down' : 'up';
        }

        function getSymbolLabel(card, index) {
            const pairEl = card.querySelector('.market-pair');
            const raw = (pairEl?.textContent || '').trim();
            if (raw) return raw;
            return `Market ${index + 1}`;
        }

        function getSymbolKey(card, index) {
            const label = getSymbolLabel(card, index);
            if (label) return label.replace('/', '');
            return `card-${index}`;
        }

        function buildSparklinePoints(seed, direction) {
            const rand = mulberry32(seed);
            const drift = direction === 'down' ? -0.03 : 0.03;
            let value = direction === 'down' ? 0.7 : 0.3;
            const points = [];

            for (let i = 0; i < SPARKLINE_POINTS; i += 1) {
                const noise = (rand() - 0.5) * 0.18;
                value = clamp(value + drift + noise, 0.1, 0.9);
                const x = (i / (SPARKLINE_POINTS - 1)) * SPARKLINE_WIDTH;
                const y = (1 - value) * SPARKLINE_HEIGHT;
                points.push({ x, y });
            }

            return points;
        }

        function createSparklineSvg(points, color) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', `0 0 ${SPARKLINE_WIDTH} ${SPARKLINE_HEIGHT}`);
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('aria-hidden', 'true');
            svg.setAttribute('focusable', 'false');

            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            const pointsAttr = points.map((point) => `${point.x},${point.y}`).join(' ');
            polyline.setAttribute('points', pointsAttr);
            polyline.setAttribute('fill', 'none');
            polyline.setAttribute('stroke', color);
            polyline.setAttribute('stroke-width', '2');
            polyline.setAttribute('stroke-linecap', 'round');
            polyline.setAttribute('stroke-linejoin', 'round');

            const last = points[points.length - 1];
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            marker.setAttribute('cx', last.x);
            marker.setAttribute('cy', last.y);
            marker.setAttribute('r', '3');
            marker.setAttribute('fill', color);

            svg.appendChild(polyline);
            svg.appendChild(marker);
            return svg;
        }

        function ensurePlaceholder(card) {
            let placeholder = card.querySelector('.sparkline-placeholder');
            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.className = 'sparkline-placeholder';
                placeholder.setAttribute('aria-hidden', 'true');
                card.appendChild(placeholder);
            }
            return placeholder;
        }

        function decorateMarketCard(card, symbolLabel) {
            if (!card) return;
            card.classList.add('market-card--interactive');
            card.setAttribute('role', 'button');
            card.tabIndex = 0;
            card.dataset.symbol = symbolLabel;
            card.setAttribute('aria-label', `Ver grafico ${symbolLabel}`);
        }

        function renderSparklines() {
            const cards = document.querySelectorAll('.market-card');
            cards.forEach((card, index) => {
                const symbolLabel = getSymbolLabel(card, index);
                const placeholder = ensurePlaceholder(card);
                const changeEl = card.querySelector('.market-change');
                const direction = getChangeDirection(changeEl);
                const symbolKey = getSymbolKey(card, index);
                const seed = hashString(symbolKey);
                const color = SPARKLINE_COLORS[direction];
                const points = buildSparklinePoints(seed, direction);

                decorateMarketCard(card, symbolLabel);
                placeholder.textContent = '';
                placeholder.appendChild(createSparklineSvg(points, color));
            });
        }

        let renderScheduled = false;
        function scheduleSparklines() {
            if (renderScheduled) return;
            renderScheduled = true;
            requestAnimationFrame(() => {
                renderScheduled = false;
                renderSparklines();
            });
        }

        const chartModal = document.getElementById('crypto-detail-modal');
        const chartTitle = document.getElementById('crypto-modal-title');
        const chartContainer = document.getElementById('crypto-chart-container');
        const chartCanvas = document.getElementById('crypto-chart-canvas');
        const CHART_POINTS = 24;
        const CHART_COLORS = {
            up: '#00ff88',
            down: '#ff0055'
        };
        let activeSymbol = null;

        function getBasePrice(symbol) {
            const upper = (symbol || '').toUpperCase();
            if (upper.includes('BTC')) return 95000;
            if (upper.includes('ETH')) return 3200;
            if (upper.includes('SOL')) return 150;
            if (upper.includes('BNB')) return 600;
            return 120;
        }

        function generateCandles(symbol, count = CHART_POINTS) {
            const seed = hashString(symbol || 'market');
            const rand = mulberry32(seed);
            const base = getBasePrice(symbol);
            const volatility = base * 0.006;
            let lastClose = base;
            const candles = [];

            for (let i = 0; i < count; i += 1) {
                const open = lastClose;
                const move = (rand() - 0.5) * volatility;
                const close = clamp(open + move, base * 0.7, base * 1.3);
                const high = Math.max(open, close) + rand() * volatility * 0.4;
                const low = Math.min(open, close) - rand() * volatility * 0.4;
                candles.push({ open, high, low, close });
                lastClose = close;
            }

            return candles;
        }

        function drawCandles(candles) {
            if (!chartCanvas || !chartContainer) return;
            const rect = chartCanvas.getBoundingClientRect();
            const width = Math.max(320, Math.floor(rect.width));
            const height = Math.max(220, Math.floor(rect.height));
            const ratio = window.devicePixelRatio || 1;
            chartCanvas.width = width * ratio;
            chartCanvas.height = height * ratio;
            chartCanvas.style.width = `${width}px`;
            chartCanvas.style.height = `${height}px`;

            const ctx = chartCanvas.getContext('2d');
            if (!ctx) return;
            ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const paddingX = 16;
            const paddingY = 12;
            const chartWidth = width - paddingX * 2;
            const chartHeight = height - paddingY * 2;
            const lows = candles.map((candle) => candle.low);
            const highs = candles.map((candle) => candle.high);
            const min = Math.min(...lows);
            const max = Math.max(...highs);
            const range = max - min || 1;
            const step = chartWidth / candles.length;
            const candleWidth = Math.max(4, step * 0.6);

            candles.forEach((candle, index) => {
                const x = paddingX + index * step + (step - candleWidth) / 2;
                const highY = paddingY + (1 - (candle.high - min) / range) * chartHeight;
                const lowY = paddingY + (1 - (candle.low - min) / range) * chartHeight;
                const openY = paddingY + (1 - (candle.open - min) / range) * chartHeight;
                const closeY = paddingY + (1 - (candle.close - min) / range) * chartHeight;
                const isUp = candle.close >= candle.open;
                const color = isUp ? CHART_COLORS.up : CHART_COLORS.down;

                ctx.strokeStyle = color;
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.moveTo(x + candleWidth / 2, highY);
                ctx.lineTo(x + candleWidth / 2, lowY);
                ctx.stroke();

                ctx.fillStyle = color;
                const bodyY = Math.min(openY, closeY);
                const bodyHeight = Math.max(2, Math.abs(closeY - openY));
                ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
            });
        }

        function renderChart(symbol) {
            const candles = generateCandles(symbol, CHART_POINTS);
            drawCandles(candles);
        }

        function openChartModal(symbol) {
            if (!chartModal || !chartContainer) return;
            const dropdown = document.getElementById('notifications-dropdown');
            if (dropdown) dropdown.remove();
            activeSymbol = symbol || 'Market';
            if (chartTitle) chartTitle.textContent = activeSymbol;
            chartModal.classList.add('is-open');
            chartModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('crypto-modal-open');
            requestAnimationFrame(() => renderChart(activeSymbol));
        }

        function closeChartModal() {
            if (!chartModal) return;
            chartModal.classList.remove('is-open');
            chartModal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('crypto-modal-open');
            activeSymbol = null;
        }

        const marketGrid = document.getElementById('market-grid');
        if (marketGrid && !window.__cryptoSparklineObserver) {
            scheduleSparklines();
            const observer = new MutationObserver(() => scheduleSparklines());
            observer.observe(marketGrid, { childList: true });
            window.__cryptoSparklineObserver = observer;
        }

        if (marketGrid && !window.__cryptoChartBound) {
            window.__cryptoChartBound = true;
            marketGrid.addEventListener('click', (event) => {
                const card = event.target.closest('.market-card');
                if (!card) return;
                const symbol = card.dataset.symbol
                    || card.querySelector('.market-pair')?.textContent?.trim()
                    || 'Market';
                openChartModal(symbol);
            });

            marketGrid.addEventListener('keydown', (event) => {
                if (event.key !== 'Enter' && event.key !== ' ') return;
                const card = event.target.closest('.market-card');
                if (!card) return;
                event.preventDefault();
                const symbol = card.dataset.symbol
                    || card.querySelector('.market-pair')?.textContent?.trim()
                    || 'Market';
                openChartModal(symbol);
            });
        }

        if (chartModal) {
            chartModal.addEventListener('click', (event) => {
                if (event.target.closest('[data-modal-close]')) {
                    closeChartModal();
                }
            });
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && chartModal?.classList.contains('is-open')) {
                closeChartModal();
            }
        });

        window.addEventListener('resize', () => {
            if (chartModal?.classList.contains('is-open') && activeSymbol) {
                renderChart(activeSymbol);
            }
        });
    </script>
</body>

</html>
